import { Injectable } from '@angular/core';
import { saveAs } from 'file-saver';
import * as i0 from "@angular/core";
/** Check the `Blob` existance only once. */
let isFileSaverSupported;
try {
    isFileSaverSupported = !!new Blob();
}
catch {
    isFileSaverSupported = false;
}
class FileSaverService {
    get isFileSaverSupported() {
        return isFileSaverSupported;
    }
    genType(fileName) {
        if (!fileName || fileName.lastIndexOf('.') === -1) {
            return 'text/plain';
        }
        const type = fileName.substring(fileName.lastIndexOf('.') + 1);
        switch (type) {
            case 'txt':
                return 'text/plain';
            case 'xml':
            case 'html':
                return `text/${type}`;
            case 'json':
                return 'octet/stream';
            default:
                return `application/${type}`;
        }
    }
    save(blob, fileName, filtType, option) {
        if (!blob) {
            throw new Error('Data argument should be a blob instance');
        }
        const file = new Blob([blob], { type: filtType || blob.type || this.genType(fileName) });
        saveAs(file, decodeURI(fileName || 'download'), option);
    }
    saveText(txt, fileName, option) {
        const blob = new Blob([txt]);
        this.save(blob, fileName, undefined, option);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: FileSaverService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: FileSaverService, providedIn: 'root' }); }
}
export { FileSaverService };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.0.4", ngImport: i0, type: FileSaverService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXNhdmVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvc3JjL2ZpbGVzYXZlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLE1BQU0sRUFBb0IsTUFBTSxZQUFZLENBQUM7O0FBRXRELDRDQUE0QztBQUM1QyxJQUFJLG9CQUE2QixDQUFDO0FBQ2xDLElBQUk7SUFDRixvQkFBb0IsR0FBRyxDQUFDLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztDQUNyQztBQUFDLE1BQU07SUFDTixvQkFBb0IsR0FBRyxLQUFLLENBQUM7Q0FDOUI7QUFFRCxNQUNhLGdCQUFnQjtJQUMzQixJQUFJLG9CQUFvQjtRQUN0QixPQUFPLG9CQUFvQixDQUFDO0lBQzlCLENBQUM7SUFFRCxPQUFPLENBQUMsUUFBaUI7UUFDdkIsSUFBSSxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1lBQ2pELE9BQU8sWUFBWSxDQUFDO1NBQ3JCO1FBQ0QsTUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQy9ELFFBQVEsSUFBSSxFQUFFO1lBQ1osS0FBSyxLQUFLO2dCQUNSLE9BQU8sWUFBWSxDQUFDO1lBQ3RCLEtBQUssS0FBSyxDQUFDO1lBQ1gsS0FBSyxNQUFNO2dCQUNULE9BQU8sUUFBUSxJQUFJLEVBQUUsQ0FBQztZQUN4QixLQUFLLE1BQU07Z0JBQ1QsT0FBTyxjQUFjLENBQUM7WUFDeEI7Z0JBQ0UsT0FBTyxlQUFlLElBQUksRUFBRSxDQUFDO1NBQ2hDO0lBQ0gsQ0FBQztJQUVELElBQUksQ0FBQyxJQUFpQixFQUFFLFFBQWlCLEVBQUUsUUFBaUIsRUFBRSxNQUF5QjtRQUNyRixJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1QsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1NBQzVEO1FBRUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6RixNQUFNLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxRQUFRLElBQUksVUFBVSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVELFFBQVEsQ0FBQyxHQUFXLEVBQUUsUUFBaUIsRUFBRSxNQUF5QjtRQUNoRSxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUMvQyxDQUFDOzhHQW5DVSxnQkFBZ0I7a0hBQWhCLGdCQUFnQixjQURILE1BQU07O1NBQ25CLGdCQUFnQjsyRkFBaEIsZ0JBQWdCO2tCQUQ1QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHNhdmVBcywgRmlsZVNhdmVyT3B0aW9ucyB9IGZyb20gJ2ZpbGUtc2F2ZXInO1xuXG4vKiogQ2hlY2sgdGhlIGBCbG9iYCBleGlzdGFuY2Ugb25seSBvbmNlLiAqL1xubGV0IGlzRmlsZVNhdmVyU3VwcG9ydGVkOiBib29sZWFuO1xudHJ5IHtcbiAgaXNGaWxlU2F2ZXJTdXBwb3J0ZWQgPSAhIW5ldyBCbG9iKCk7XG59IGNhdGNoIHtcbiAgaXNGaWxlU2F2ZXJTdXBwb3J0ZWQgPSBmYWxzZTtcbn1cblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBGaWxlU2F2ZXJTZXJ2aWNlIHtcbiAgZ2V0IGlzRmlsZVNhdmVyU3VwcG9ydGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc0ZpbGVTYXZlclN1cHBvcnRlZDtcbiAgfVxuXG4gIGdlblR5cGUoZmlsZU5hbWU/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghZmlsZU5hbWUgfHwgZmlsZU5hbWUubGFzdEluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAndGV4dC9wbGFpbic7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBmaWxlTmFtZS5zdWJzdHJpbmcoZmlsZU5hbWUubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAndHh0JzpcbiAgICAgICAgcmV0dXJuICd0ZXh0L3BsYWluJztcbiAgICAgIGNhc2UgJ3htbCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIGB0ZXh0LyR7dHlwZX1gO1xuICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgIHJldHVybiAnb2N0ZXQvc3RyZWFtJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgYXBwbGljYXRpb24vJHt0eXBlfWA7XG4gICAgfVxuICB9XG5cbiAgc2F2ZShibG9iOiBCbG9iIHwgbnVsbCwgZmlsZU5hbWU/OiBzdHJpbmcsIGZpbHRUeXBlPzogc3RyaW5nLCBvcHRpb24/OiBGaWxlU2F2ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKCFibG9iKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgYXJndW1lbnQgc2hvdWxkIGJlIGEgYmxvYiBpbnN0YW5jZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGUgPSBuZXcgQmxvYihbYmxvYl0sIHsgdHlwZTogZmlsdFR5cGUgfHwgYmxvYi50eXBlIHx8IHRoaXMuZ2VuVHlwZShmaWxlTmFtZSkgfSk7XG4gICAgc2F2ZUFzKGZpbGUsIGRlY29kZVVSSShmaWxlTmFtZSB8fCAnZG93bmxvYWQnKSwgb3B0aW9uKTtcbiAgfVxuXG4gIHNhdmVUZXh0KHR4dDogc3RyaW5nLCBmaWxlTmFtZT86IHN0cmluZywgb3B0aW9uPzogRmlsZVNhdmVyT3B0aW9ucyk6IHZvaWQge1xuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbdHh0XSk7XG4gICAgdGhpcy5zYXZlKGJsb2IsIGZpbGVOYW1lLCB1bmRlZmluZWQsIG9wdGlvbik7XG4gIH1cbn1cbiJdfQ==